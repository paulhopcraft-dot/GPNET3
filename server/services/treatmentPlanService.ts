/**
 * Treatment Plan Service
 *
 * Generates AI-powered treatment plans with interventions, milestones, and outcomes.
 * PRD-9 compliant: Advisory only, no medical liability.
 *
 * Constraints:
 * - Claude API timeout: <30s
 * - Storage: clinical_status_json JSONB only
 * - NO PII in logs
 * - Disclaimers everywhere
 */

import Anthropic from "@anthropic-ai/sdk";
import type { IStorage } from "../storage";
import { logger } from "../lib/logger";
import type {
  TreatmentPlan,
  TreatmentIntervention,
  TreatmentMilestone,
  CaseClinicalStatus,
  WorkerCase,
} from "@shared/schema";
import { fetchCaseContext } from "./smartSummary";
import { calculateRecoveryTimeline, extractInjuryType, getInjuryModel } from "./recoveryEstimator";
import { evaluateClinicalEvidence } from "./clinicalEvidence";
import { logAuditEvent } from "./auditLogger";
import { randomUUID } from "crypto";

const MODEL = "claude-3-haiku-20240307";
const MAX_TOKENS = 3072;
const TIMEOUT_MS = 30000;

const DISCLAIMER_TEXT = `⚠️ ADVISORY ONLY

This treatment plan is generated by AI for care coordination purposes only. It does NOT constitute medical advice, diagnosis, or treatment recommendations.

All treatment decisions must be made by qualified healthcare professionals. This plan is intended to assist case managers in coordinating care and facilitating communication between stakeholders.

WorkSafe Victoria compliance: This is a coordination tool, not a medical directive.`;

/**
 * Sanitize user input to prevent prompt injection attacks
 * - Removes control characters that could break prompt structure
 * - Limits length (already enforced by Zod, but defensive)
 * - Escapes XML special characters for safe interpolation
 */
function sanitizeUserInput(input: string): string {
  return input
    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "") // Remove control chars
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;")
    .substring(0, 5000); // Hard limit, even though Zod validates at 10000
}

export interface GenerateTreatmentPlanRequest {
  caseId: string;
  organizationId: string;
  additionalContext?: string;
}

export interface UpdateTreatmentPlanRequest {
  status?: "active" | "completed" | "archived";
  notes?: string;
}

interface AITreatmentPlanResponse {
  interventions: TreatmentIntervention[];
  milestones: TreatmentMilestone[];
  specialistReferrals?: string[];
  diagnosticTests?: string[];
  expectedDurationWeeks: number;
  expectedOutcomes: string[];
  successCriteria?: string[];
  factorsConsidered: string[];
  plateauAnalysis?: string;
}

/**
 * Build AI prompt for treatment plan generation
 * Uses injury models for appropriate specialist and diagnostic recommendations
 */
function buildTreatmentPrompt(
  workerCase: WorkerCase,
  recoveryEstimate: any,
  clinicalFlags: string[],
  additionalContext?: string
): string {
  const summary = workerCase.summary || "Workplace injury (details pending)";
  const constraints = workerCase.clinical_status_json?.medicalConstraints;
  const capacity = workerCase.clinical_status_json?.functionalCapacity;

  // Detect injury type and get injury-specific model
  const injuryType = extractInjuryType(summary);
  const injuryModel = getInjuryModel(injuryType);

  const constraintsText = constraints
    ? `
MEDICAL CONSTRAINTS:
${constraints.noLiftingOverKg ? `- No lifting over ${constraints.noLiftingOverKg}kg` : ""}
${constraints.noBending ? "- No bending" : ""}
${constraints.noTwisting ? "- No twisting" : ""}
${constraints.noProlongedStanding ? "- No prolonged standing" : ""}
${constraints.noProlongedSitting ? "- No prolonged sitting" : ""}
${constraints.otherConstraints || ""}
`.trim()
    : "No medical constraints documented.";

  const capacityText = capacity
    ? `
FUNCTIONAL CAPACITY:
${capacity.canLiftKg !== undefined ? `- Can lift: ${capacity.canLiftKg}kg` : ""}
${capacity.canStandMinutes !== undefined ? `- Can stand: ${capacity.canStandMinutes} minutes` : ""}
${capacity.canSitMinutes !== undefined ? `- Can sit: ${capacity.canSitMinutes} minutes` : ""}
${capacity.maxWorkHoursPerDay !== undefined ? `- Max work hours/day: ${capacity.maxWorkHoursPerDay}` : ""}
`.trim()
    : "No functional capacity assessment documented.";

  // Build injury-specific guidance
  const injuryGuidance = injuryType !== "unknown" ? `
INJURY-SPECIFIC GUIDANCE (${injuryType.replace(/_/g, ' ').toUpperCase()}):
This is a ${injuryType.replace(/_/g, ' ')} injury. Based on medical guidelines:

APPROPRIATE SPECIALIST REFERRALS for this injury type:
${injuryModel.specialistReferrals.map(s => `- ${s}`).join('\n')}

APPROPRIATE DIAGNOSTIC TESTS for this injury type:
${injuryModel.diagnosticTests.map(t => `- ${t}`).join('\n')}

RISK FACTORS to consider:
${injuryModel.riskFactors.map(r => `- ${r}`).join('\n')}

IMPORTANT: Only recommend specialists and tests that are appropriate for this SPECIFIC injury type.
- DO NOT recommend orthopedic specialist for hand/finger injuries (recommend hand surgeon instead)
- DO NOT recommend psychological assessment unless there are documented psychological factors
- Match your recommendations to the injury location and type
` : `
INJURY TYPE: Unknown/Unspecified
Since the injury type is unclear, recommend:
- GP assessment to clarify diagnosis
- Appropriate specialist once injury type is confirmed
- Conservative treatment until diagnosis is clear
`;

  return `You are a care coordination assistant helping case managers develop treatment plans for workplace injury cases in Australia.

IMPORTANT: You are providing ADVISORY RECOMMENDATIONS only, NOT medical treatment decisions. All recommendations must be reviewed and approved by qualified healthcare professionals.

CASE INFORMATION:
- Worker: [REDACTED - no PII in prompts]
- Injury Description: ${summary}
- Detected Injury Type: ${injuryType.replace(/_/g, ' ')}
- Risk Level: ${workerCase.riskLevel}
- Work Status: ${workerCase.workStatus}
- Date of Injury: ${workerCase.dateOfInjury}

${injuryGuidance}

${constraintsText}

${capacityText}

RECOVERY ESTIMATE:
- Expected duration: ${recoveryEstimate.estimatedWeeks || injuryModel.baselineWeeks} weeks
- Confidence: ${recoveryEstimate.confidence || "medium"}

CLINICAL FLAGS:
${clinicalFlags.length > 0 ? clinicalFlags.map((f) => `- ${f}`).join("\n") : "No clinical flags"}

${additionalContext ? `<user_provided_context>\n${sanitizeUserInput(additionalContext)}\n</user_provided_context>\n` : ""}

${additionalContext?.includes('PLATEAU') ? `
PLATEAU DETECTED - IMPORTANT:
Recovery has plateaued. Focus recommendations on:
1. Diagnostic tests from the list above that haven't been done
2. Specialist referrals appropriate for THIS injury type only
3. Alternative treatment approaches
4. DO NOT add psychological unless specifically indicated by case notes
` : ''}

Generate a structured treatment plan with:
1. **Interventions**: Specific treatment types (physiotherapy, medication, specialist referrals, workplace modifications, etc.)
2. **Milestones**: Week-by-week recovery checkpoints
3. **Expected Outcomes**: What success looks like
4. **Specialist Referrals**: If needed (orthopedic, pain specialist, psychologist, etc.)
5. **Success Criteria**: Objective measures
${additionalContext?.includes('PLATEAU') ? '6. **Diagnostic Tests**: Specific tests recommended based on injury type and plateau duration' : ''}

Return ONLY valid JSON matching this exact structure (no markdown, no code blocks):

{
  "interventions": [
    {
      "type": "physiotherapy" | "medication" | "specialist" | "surgical" | "workplace_modification" | "psychological" | "diagnostic" | "other",
      "description": "Specific intervention description",
      "frequency": "e.g., 3x per week",
      "duration": "e.g., 6 weeks",
      "priority": "critical" | "recommended" | "optional"
    }
  ],
  "milestones": [
    {
      "weekNumber": 2,
      "description": "Milestone description",
      "expectedOutcome": "Expected result"
    }
  ],
  "specialistReferrals": ["Specialist type if needed"],
  "diagnosticTests": ["MRI lumbar spine", "Nerve conduction study"],
  "expectedDurationWeeks": 8,
  "expectedOutcomes": ["Return to full duties", "Pain-free movement"],
  "successCriteria": ["Objective measure 1", "Objective measure 2"],
  "factorsConsidered": ["Factor 1", "Factor 2"],
  "plateauAnalysis": "If plateau detected, explain likely causes and recommended approach"
}

Focus on practical, achievable interventions appropriate for Australian workplace injury management under WorkSafe Victoria guidelines.`;
}

/**
 * Calculate confidence score based on data quality
 */
function calculateConfidence(workerCase: WorkerCase, aiResponse: AITreatmentPlanResponse): number {
  let confidence = 50; // Base confidence

  // Increase confidence for good data
  if (workerCase.summary && workerCase.summary.length > 50) confidence += 10;
  if (workerCase.clinical_status_json?.medicalConstraints) confidence += 10;
  if (workerCase.clinical_status_json?.functionalCapacity) confidence += 10;
  if (workerCase.hasCertificate) confidence += 10;
  if (workerCase.riskLevel === "Low") confidence += 10;

  // Decrease confidence for missing data or high risk
  if (!workerCase.summary || workerCase.summary.length < 20) confidence -= 15;
  if (workerCase.riskLevel === "High") confidence -= 10;
  if (aiResponse.interventions.length === 0) confidence -= 20;

  // Clamp between 0-100
  return Math.max(0, Math.min(100, confidence));
}

/**
 * Create fallback plan when AI fails
 */
function createFallbackPlan(workerCase: WorkerCase): TreatmentPlan {
  const id = randomUUID();
  const now = new Date().toISOString();

  return {
    id,
    status: "active",
    generatedAt: now,
    generatedBy: "ai",
    aiModel: MODEL,
    confidence: 30, // Low confidence for fallback
    injuryType: "unknown",
    interventions: [
      {
        type: "other",
        description: "Consult with treating medical practitioner for treatment plan",
        priority: "critical",
      },
    ],
    milestones: [
      {
        weekNumber: 2,
        description: "Initial review",
        expectedOutcome: "Treatment plan established with medical practitioner",
      },
    ],
    expectedDurationWeeks: 12,
    expectedOutcomes: ["Medical treatment plan established", "Recovery progressing as expected"],
    factorsConsidered: ["AI generation failed - manual review required"],
    disclaimerText: DISCLAIMER_TEXT,
  };
}

/**
 * Generate treatment plan using Claude AI
 */
export async function generateTreatmentPlan(
  storage: IStorage,
  request: GenerateTreatmentPlanRequest
): Promise<TreatmentPlan> {
  const { caseId, organizationId, additionalContext } = request;

  // Fetch case
  const workerCase = await storage.getGPNet2CaseById(caseId, organizationId);
  if (!workerCase) {
    throw new Error("Case not found");
  }

  try {
    // Fetch context and estimate recovery timeline
    const context = await fetchCaseContext(storage, caseId, organizationId);
    const clinicalEvidence = evaluateClinicalEvidence(workerCase);
    const recoveryEstimate = calculateRecoveryTimeline({
      dateOfInjury: workerCase.dateOfInjury,
      summary: workerCase.summary || "",
      riskLevel: workerCase.riskLevel as "High" | "Medium" | "Low",
      clinicalFlags: clinicalEvidence.flags || [],
    });

    // Build prompt
    const prompt = buildTreatmentPrompt(
      workerCase,
      recoveryEstimate,
      clinicalEvidence.flags.map((f) => f.message),
      additionalContext
    );

    // Call Claude API with timeout
    const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
    const response = await Promise.race([
      anthropic.messages.create({
        model: MODEL,
        max_tokens: MAX_TOKENS,
        messages: [{ role: "user", content: prompt }],
      }),
      new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), TIMEOUT_MS)),
    ]) as Anthropic.Message;

    // Parse AI response
    const textContent = response.content.find((c) => c.type === "text");
    if (!textContent || textContent.type !== "text") {
      logger.ai.error("No text content in AI response", { caseId });
      return createFallbackPlan(workerCase);
    }

    let aiResponse: AITreatmentPlanResponse;
    try {
      aiResponse = JSON.parse(textContent.text);
    } catch (parseError) {
      logger.ai.error("Treatment plan JSON parse error", { caseId }, parseError);
      return createFallbackPlan(workerCase);
    }

    // Build treatment plan
    const id = randomUUID();
    const now = new Date().toISOString();
    const confidence = calculateConfidence(workerCase, aiResponse);

    const plan: TreatmentPlan = {
      id,
      status: "active",
      generatedAt: now,
      generatedBy: "ai",
      aiModel: MODEL,
      confidence,
      injuryType: workerCase.summary || "unknown",
      diagnosisSummary: workerCase.summary,
      interventions: aiResponse.interventions,
      specialistReferrals: aiResponse.specialistReferrals,
      diagnosticTests: aiResponse.diagnosticTests,
      expectedDurationWeeks: aiResponse.expectedDurationWeeks,
      milestones: aiResponse.milestones,
      expectedOutcomes: aiResponse.expectedOutcomes,
      successCriteria: aiResponse.successCriteria,
      factorsConsidered: aiResponse.factorsConsidered,
      disclaimerText: DISCLAIMER_TEXT,
      plateauAnalysis: aiResponse.plateauAnalysis,
    };

    // Supersede existing plan if present
    const existingStatus = workerCase.clinical_status_json || {};
    const existingPlan = existingStatus.treatmentPlan;
    const history = existingStatus.treatmentPlanHistory || [];

    if (existingPlan && existingPlan.status === "active") {
      // Create new superseded plan object (immutable update)
      const supersededPlan: TreatmentPlan = {
        ...existingPlan,
        status: "superseded",
        supersededAt: now,
        supersededBy: id,
      };
      history.push(supersededPlan);
    }

    // Update case with new plan
    const updatedStatus: CaseClinicalStatus = {
      ...existingStatus,
      treatmentPlan: plan,
      treatmentPlanHistory: history,
    };

    await storage.updateClinicalStatus(caseId, organizationId, updatedStatus);

    // Audit log (no PII)
    await logAuditEvent({
      organizationId,
      eventType: "ai.treatment_plan.generate" as any,
      userId: null,
      resourceType: "treatment_plan",
      resourceId: plan.id,
      metadata: {
        caseId,
        confidence: plan.confidence,
        interventionCount: plan.interventions.length,
      },
    });

    logger.ai.info("Generated treatment plan", { planId: id, caseId, confidence });
    return plan;
  } catch (error) {
    logger.ai.error("Error generating treatment plan", { caseId }, error);
    throw error;
  }
}

/**
 * Get current treatment plan for a case
 */
export async function getTreatmentPlan(
  storage: IStorage,
  caseId: string,
  organizationId: string
): Promise<TreatmentPlan | null> {
  const workerCase = await storage.getGPNet2CaseById(caseId, organizationId);
  if (!workerCase) {
    return null;
  }

  return workerCase.clinical_status_json?.treatmentPlan || null;
}

/**
 * Update treatment plan status or notes
 */
export async function updateTreatmentPlan(
  storage: IStorage,
  caseId: string,
  organizationId: string,
  planId: string,
  updates: UpdateTreatmentPlanRequest
): Promise<TreatmentPlan> {
  const workerCase = await storage.getGPNet2CaseById(caseId, organizationId);
  if (!workerCase) {
    throw new Error("Case not found");
  }

  const existingStatus = workerCase.clinical_status_json || {};
  const plan = existingStatus.treatmentPlan;

  if (!plan || plan.id !== planId) {
    throw new Error("Treatment plan not found");
  }

  // Apply updates
  if (updates.status) {
    plan.status = updates.status;
    if (updates.status === "completed") {
      plan.completedAt = new Date().toISOString();
    }
  }

  if (updates.notes !== undefined) {
    plan.notes = updates.notes;
  }

  // Save updated plan
  const updatedStatus: CaseClinicalStatus = {
    ...existingStatus,
    treatmentPlan: plan,
  };

  await storage.updateClinicalStatus(caseId, organizationId, updatedStatus);

  // Audit log
  await logAuditEvent({
    organizationId,
    eventType: "ai.treatment_plan.update" as any,
    userId: null,
    resourceType: "treatment_plan",
    resourceId: planId,
    metadata: { caseId, updates },
  });

  logger.ai.info("Updated treatment plan", { planId, caseId });
  return plan;
}
