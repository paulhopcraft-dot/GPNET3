---
phase: 11-system-wide-testing
plan: 06
type: execute
wave: 3
depends_on: ["11-02", "11-03", "11-04"]
files_modified:
  - tests/integration/database/integrity.test.ts
  - tests/e2e/edge-cases/error-handling.spec.ts
autonomous: true

must_haves:
  truths:
    - "All certificates reference valid cases (no orphans)"
    - "All actions reference valid cases (no orphans)"
    - "No duplicate case IDs exist"
    - "Error handling is graceful (no infinite loops, proper error messages)"
    - "Recovery chart certificate dots display correctly"
  artifacts:
    - path: "tests/integration/database/integrity.test.ts"
      provides: "Database integrity tests using Vitest"
      contains: "orphan"
    - path: "tests/e2e/edge-cases/error-handling.spec.ts"
      provides: "Edge case and error handling E2E tests"
      contains: "tag.*@regression"
  key_links:
    - from: "tests/integration/database/integrity.test.ts"
      to: "shared/schema.ts"
      via: "import for table references"
      pattern: "import.*schema"
---

<objective>
Create database integrity tests and edge case/error handling tests.

Purpose: Database integrity ensures referential integrity (no orphan records, no duplicates). Edge case tests verify the system handles errors gracefully without infinite loops or crashes.

Output: Database integrity tests (Vitest) and error handling E2E tests (Playwright).
</objective>

<execution_context>
@C:\Users\Paul\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Paul\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-system-wide-testing/11-RESEARCH.md
@.planning/phases/11-system-wide-testing/11-01-SUMMARY.md

# Database schema reference
@shared/schema.ts

# Fixtures from Plan 01
@tests/e2e/fixtures/auth.fixture.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database integrity tests</name>
  <files>tests/integration/database/integrity.test.ts</files>
  <action>
Create tests/integration/database/ directory and integrity.test.ts:

```typescript
import { describe, it, expect, beforeAll } from 'vitest';
import { db } from '../../../server/db';
import { sql } from 'drizzle-orm';

// Note: These tests require database connection
// Skip if DATABASE_URL not set
const skipIfNoDb = !process.env.DATABASE_URL;

describe.skipIf(skipIfNoDb)('Database Integrity', () => {
  beforeAll(async () => {
    // Verify database connection
    try {
      await db.execute(sql`SELECT 1`);
    } catch (error) {
      console.error('Database connection failed - skipping integrity tests');
      throw error;
    }
  });

  it('all certificates reference valid cases', async () => {
    const orphanCerts = await db.execute(sql`
      SELECT mc.id, mc.case_id
      FROM medical_certificates mc
      LEFT JOIN worker_cases wc ON mc.case_id = wc.id
      WHERE wc.id IS NULL
    `);

    if (orphanCerts.rows.length > 0) {
      console.log('Orphan certificates found:', orphanCerts.rows);
    }

    expect(orphanCerts.rows).toHaveLength(0);
  });

  it('all actions reference valid cases', async () => {
    const orphanActions = await db.execute(sql`
      SELECT ca.id, ca.case_id
      FROM case_actions ca
      LEFT JOIN worker_cases wc ON ca.case_id = wc.id
      WHERE wc.id IS NULL
    `);

    if (orphanActions.rows.length > 0) {
      console.log('Orphan actions found:', orphanActions.rows);
    }

    expect(orphanActions.rows).toHaveLength(0);
  });

  it('no duplicate case IDs exist', async () => {
    const duplicates = await db.execute(sql`
      SELECT id, COUNT(*) as count
      FROM worker_cases
      GROUP BY id
      HAVING COUNT(*) > 1
    `);

    if (duplicates.rows.length > 0) {
      console.log('Duplicate case IDs:', duplicates.rows);
    }

    expect(duplicates.rows).toHaveLength(0);
  });

  it('all users have valid email format', async () => {
    const invalidEmails = await db.execute(sql`
      SELECT id, email
      FROM users
      WHERE email NOT LIKE '%@%.%'
    `);

    if (invalidEmails.rows.length > 0) {
      console.log('Invalid emails:', invalidEmails.rows);
    }

    expect(invalidEmails.rows).toHaveLength(0);
  });

  it('all termination processes reference valid cases', async () => {
    const orphanTerminations = await db.execute(sql`
      SELECT tp.id, tp.case_id
      FROM termination_processes tp
      LEFT JOIN worker_cases wc ON tp.case_id = wc.id
      WHERE wc.id IS NULL
    `);

    if (orphanTerminations.rows.length > 0) {
      console.log('Orphan termination processes:', orphanTerminations.rows);
    }

    expect(orphanTerminations.rows).toHaveLength(0);
  });

  it('case counts are consistent', async () => {
    const caseCount = await db.execute(sql`SELECT COUNT(*) as count FROM worker_cases`);
    const count = Number(caseCount.rows[0]?.count || 0);

    // Should have at least some cases in a functioning system
    console.log(`Total cases: ${count}`);

    // Informational - don't fail if no cases
    expect(count).toBeGreaterThanOrEqual(0);
  });

  it('no null foreign keys in required relationships', async () => {
    // Check certificates have case_id
    const nullCaseCerts = await db.execute(sql`
      SELECT COUNT(*) as count
      FROM medical_certificates
      WHERE case_id IS NULL
    `);

    expect(Number(nullCaseCerts.rows[0]?.count || 0)).toBe(0);

    // Check actions have case_id
    const nullCaseActions = await db.execute(sql`
      SELECT COUNT(*) as count
      FROM case_actions
      WHERE case_id IS NULL
    `);

    expect(Number(nullCaseActions.rows[0]?.count || 0)).toBe(0);
  });
});
```

Tests run against actual database to verify referential integrity.
Skips gracefully if no database connection available.
  </action>
  <verify>
    - File exists at tests/integration/database/integrity.test.ts
    - Tests skip gracefully if DATABASE_URL not set
    - `npm test -- tests/integration/database` runs without errors
  </verify>
  <done>Database integrity tests created</done>
</task>

<task type="auto">
  <name>Task 2: Create error handling edge case tests</name>
  <files>tests/e2e/edge-cases/error-handling.spec.ts</files>
  <action>
Create tests/e2e/edge-cases/ directory and error-handling.spec.ts:

```typescript
import { test, expect } from '../fixtures/auth.fixture';

test.describe('Error Handling', { tag: '@regression' }, () => {
  test('invalid case ID shows error gracefully', async ({ authenticatedPage: page }) => {
    await page.goto('/employer/case/invalid-case-id-12345');
    await page.waitForLoadState('networkidle');

    // Should show error message or redirect, not crash
    const pageContent = await page.content();

    // Should not show raw error stack trace
    expect(pageContent).not.toContain('TypeError');
    expect(pageContent).not.toContain('Cannot read properties');
    expect(pageContent).not.toContain('undefined is not');

    // Should show user-friendly message OR redirect to cases list
    const hasErrorMessage = pageContent.includes('not found') ||
                           pageContent.includes('Case not found') ||
                           pageContent.includes('does not exist');
    const redirectedToCases = page.url().includes('/cases');

    expect(hasErrorMessage || redirectedToCases).toBe(true);
  });

  test('network error shows retry option', async ({ authenticatedPage: page, context }) => {
    // Block a specific API endpoint
    await context.route('**/api/gpnet2/cases', route => route.abort('failed'));

    await page.goto('/cases');
    await page.waitForTimeout(3000);

    // Should show error state, not infinite spinner
    const pageContent = await page.content();

    // Should not be stuck loading forever
    const hasLoadingSpinner = await page.locator('.loading, [class*="spin"], text=Loading').isVisible({ timeout: 1000 }).catch(() => false);

    // After 3 seconds, should either show error or retry button
    if (hasLoadingSpinner) {
      // Loading should resolve within reasonable time
      await page.waitForTimeout(5000);
      const stillLoading = await page.locator('.loading, [class*="spin"]').isVisible({ timeout: 1000 }).catch(() => false);

      // Should not be infinite loading
      if (stillLoading) {
        console.warn('Loading state persisted >5s after network error');
      }
    }
  });

  test('401 error redirects to login without loop', async ({ authenticatedPage: page, context }) => {
    // Track request count
    let requestCount = 0;
    page.on('request', () => requestCount++);

    // Intercept ALL auth endpoints to simulate expired session
    await context.route('**/api/auth/**', route => route.fulfill({ status: 401 }));

    await page.goto('/cases');
    await page.waitForTimeout(5000);

    // Should redirect to login
    expect(page.url()).toMatch(/login|\/$/);

    // Should not have made excessive requests (indicates loop)
    console.log(`Total requests after 401: ${requestCount}`);
    expect(requestCount).toBeLessThan(100);
  });

  test('rate limit error shows appropriate message', async ({ authenticatedPage: page, context }) => {
    // Intercept to simulate rate limit
    await context.route('**/api/**', route => route.fulfill({
      status: 429,
      body: JSON.stringify({ error: 'Too many requests' })
    }));

    await page.goto('/cases');
    await page.waitForTimeout(2000);

    // Should handle 429 gracefully
    const pageContent = await page.content();

    // Should not crash
    expect(pageContent).not.toContain('TypeError');
    expect(pageContent).not.toContain('undefined');
  });

  test('empty data states render correctly', async ({ authenticatedPage: page }) => {
    // Navigate to cases
    await page.goto('/cases');
    await page.waitForLoadState('networkidle');

    // If table is empty, should show empty state message
    const table = page.getByRole('table');
    const rows = table.getByRole('row');
    const rowCount = await rows.count();

    if (rowCount <= 1) {
      // Only header row - should show empty state
      const emptyState = page.locator('text=/no cases|empty|no data/i');
      await expect(emptyState).toBeVisible();
    }
  });

  test('recovery chart renders without errors', async ({ authenticatedPage: page }) => {
    await page.goto('/cases');
    await page.waitForSelector('[data-testid^="row-case-"]', { timeout: 15000 });

    // Click first case to see detail
    await page.locator('[data-testid^="row-case-"]').first().click();
    await page.waitForTimeout(2000);

    // Look for recovery chart or timeline
    const recoveryChart = page.locator('[data-testid*="recovery"], [class*="chart"], [class*="timeline"]').first();

    if (await recoveryChart.isVisible({ timeout: 5000 }).catch(() => false)) {
      // Chart should not show error
      const chartContent = await recoveryChart.textContent();
      expect(chartContent).not.toContain('Error');
      expect(chartContent).not.toContain('undefined');

      // Look for certificate dots if chart exists
      const certDots = page.locator('[data-testid*="certificate-dot"], .cert-dot, circle').first();
      if (await certDots.isVisible({ timeout: 2000 }).catch(() => false)) {
        console.log('Certificate dots found in recovery chart');
      } else {
        console.log('Certificate dots not found - may be no certificates for this case');
      }
    }
  });

  test('form validation shows errors inline', async ({ authenticatedPage: page }) => {
    await page.goto('/employer/new-case');
    await page.waitForLoadState('networkidle');

    // Navigate past gateway if present
    const noOption = page.locator('label:has-text("No")').first();
    if (await noOption.isVisible({ timeout: 2000 }).catch(() => false)) {
      await noOption.click();
      await page.waitForTimeout(500);
    }

    // Try to submit without filling required fields
    const submitButton = page.locator('button:has-text("Submit"), button:has-text("Create"), button[type="submit"]').first();

    if (await submitButton.isVisible({ timeout: 3000 }).catch(() => false)) {
      await submitButton.click();
      await page.waitForTimeout(1000);

      // Should show validation errors inline, not just fail silently
      const hasValidationError = await page.locator('text=/required|invalid|please|must/i').isVisible({ timeout: 3000 }).catch(() => false);

      // Either shows validation or button is disabled for incomplete form
      const buttonDisabled = await submitButton.isDisabled();

      expect(hasValidationError || buttonDisabled).toBe(true);
    }
  });
});
```

Tests edge cases and error handling scenarios.
Verifies graceful degradation without infinite loops or crashes.
  </action>
  <verify>
    - npm run test:e2e:regression -- --list shows error-handling tests
    - Tests cover: invalid IDs, network errors, 401 handling, rate limits
  </verify>
  <done>Error handling edge case tests created</done>
</task>

<task type="auto">
  <name>Task 3: Create recovery chart specific tests</name>
  <files>tests/e2e/edge-cases/error-handling.spec.ts</files>
  <action>
Add recovery chart certificate dots test to the same file (append to test.describe):

```typescript
  test('certificate dots display on recovery chart', { tag: '@critical' }, async ({ authenticatedPage: page }) => {
    await page.goto('/cases');
    await page.waitForSelector('[data-testid^="row-case-"]', { timeout: 15000 });

    // Find a case that likely has certificates (look for one with more data)
    const caseRows = page.locator('[data-testid^="row-case-"]');
    const rowCount = await caseRows.count();

    let foundCertDots = false;

    // Try first few cases to find one with certificates
    for (let i = 0; i < Math.min(3, rowCount); i++) {
      await caseRows.nth(i).click();
      await page.waitForTimeout(2000);

      // Look for recovery chart
      const recoveryChart = page.locator('[data-testid*="recovery-chart"], [class*="RecoveryChart"], canvas, svg').first();

      if (await recoveryChart.isVisible({ timeout: 3000 }).catch(() => false)) {
        // Check for certificate markers/dots
        const certDots = page.locator(
          '[data-testid*="certificate"], ' +
          '.certificate-marker, ' +
          '.cert-dot, ' +
          'circle[fill], ' +
          '[class*="marker"]'
        );

        const dotCount = await certDots.count();
        console.log(`Case ${i+1}: Found ${dotCount} certificate markers`);

        if (dotCount > 0) {
          foundCertDots = true;

          // Verify dots are visible
          await expect(certDots.first()).toBeVisible();

          // Verify dots have proper position (not all at 0,0)
          const firstDot = certDots.first();
          const box = await firstDot.boundingBox();
          if (box) {
            expect(box.x).toBeGreaterThan(0);
            expect(box.y).toBeGreaterThan(0);
          }

          break;
        }
      }
    }

    if (!foundCertDots) {
      console.log('No certificate dots found - may be no certificates in test data or chart not implemented');
    }
  });

  test('certificate dot click shows certificate details', async ({ authenticatedPage: page }) => {
    await page.goto('/cases');
    await page.waitForSelector('[data-testid^="row-case-"]', { timeout: 15000 });

    await page.locator('[data-testid^="row-case-"]').first().click();
    await page.waitForTimeout(2000);

    // Find certificate dots/markers
    const certDots = page.locator('[data-testid*="certificate-dot"], .certificate-marker, .cert-dot');

    if (await certDots.count() > 0) {
      // Click first certificate dot
      await certDots.first().click();
      await page.waitForTimeout(1000);

      // Should show certificate details (modal, panel, or expand)
      const certDetails = page.locator(
        '[data-testid*="certificate-detail"], ' +
        '[class*="certificate"], ' +
        'text=/certificate|restriction|diagnosis/i'
      );

      const detailsVisible = await certDetails.isVisible({ timeout: 3000 }).catch(() => false);
      console.log(`Certificate details visible after click: ${detailsVisible}`);
    } else {
      console.log('No certificate dots to click');
    }
  });
```

These tests specifically address the "Recovery chart displays certificate dots correctly" success criteria from Phase 11.
  </action>
  <verify>
    - Recovery chart tests added to error-handling.spec.ts
    - Tests check for certificate dots visibility and positioning
  </verify>
  <done>Recovery chart certificate dot tests created</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm test -- tests/integration/database` runs integrity tests
2. `npm run test:e2e:regression -- --list` shows edge-case tests
3. Tests cover database integrity and error handling
4. Recovery chart certificate dots tested
</verification>

<success_criteria>
- tests/integration/database/integrity.test.ts exists with orphan/duplicate checks
- tests/e2e/edge-cases/error-handling.spec.ts exists with error handling tests
- Database tests check referential integrity
- Edge case tests verify graceful error handling
- Recovery chart tests verify certificate dots display
</success_criteria>

<output>
After completion, create `.planning/phases/11-system-wide-testing/11-06-SUMMARY.md`
</output>
