---
phase: 11-system-wide-testing
plan: 07
type: execute
wave: 4
depends_on: ["11-02", "11-03", "11-04", "11-05", "11-06"]
files_modified:
  - tests/test-report-generator.ts
  - package.json
autonomous: false

must_haves:
  truths:
    - "All smoke tests pass"
    - "All critical path tests pass"
    - "Performance tests establish baseline"
    - "Database integrity verified"
    - "Test report generated with pass/fail summary"
  artifacts:
    - path: "tests/test-report-generator.ts"
      provides: "Script to run all tests and generate summary report"
      exports: []
  key_links:
    - from: "tests/test-report-generator.ts"
      to: "package.json"
      via: "npm scripts for test execution"
      pattern: "test:e2e"
---

<objective>
Run all tests and generate comprehensive test report.

Purpose: Execute the complete test suite in wave order (smoke -> critical -> regression -> performance) and produce a summary report showing pass/fail status, timing, and any issues found.

Output: Test report generator script and execution of full test suite.
</objective>

<execution_context>
@C:\Users\Paul\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Paul\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-system-wide-testing/11-RESEARCH.md
@.planning/phases/11-system-wide-testing/11-01-SUMMARY.md
@.planning/phases/11-system-wide-testing/11-02-SUMMARY.md
@.planning/phases/11-system-wide-testing/11-03-SUMMARY.md
@.planning/phases/11-system-wide-testing/11-04-SUMMARY.md
@.planning/phases/11-system-wide-testing/11-05-SUMMARY.md
@.planning/phases/11-system-wide-testing/11-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test report generator script</name>
  <files>tests/test-report-generator.ts</files>
  <action>
Create tests/test-report-generator.ts:

```typescript
/**
 * Test Report Generator
 * Runs all tests in wave order and generates summary report
 */

import { execSync, spawn } from 'child_process';
import * as fs from 'fs';

interface TestResult {
  wave: string;
  name: string;
  passed: number;
  failed: number;
  skipped: number;
  duration: number;
  errors: string[];
}

interface ReportData {
  timestamp: string;
  results: TestResult[];
  summary: {
    totalPassed: number;
    totalFailed: number;
    totalSkipped: number;
    totalDuration: number;
  };
}

async function runTests(): Promise<ReportData> {
  const results: TestResult[] = [];
  const timestamp = new Date().toISOString();

  console.log('\n================================');
  console.log('SYSTEM-WIDE TEST SUITE');
  console.log('================================\n');

  // Wave 1: Smoke Tests
  console.log('Wave 1: Running Smoke Tests...');
  const smokeResult = await runTestWave('@smoke', 'Smoke Tests');
  results.push(smokeResult);

  if (smokeResult.failed > 0) {
    console.log('WARNING: Smoke tests failed. System may have issues.');
  }

  // Wave 2: Critical Path Tests
  console.log('\nWave 2: Running Critical Path Tests...');
  const criticalResult = await runTestWave('@critical', 'Critical Path');
  results.push(criticalResult);

  // Wave 3: Regression Tests
  console.log('\nWave 3: Running Regression Tests...');
  const regressionResult = await runTestWave('@regression', 'Regression');
  results.push(regressionResult);

  // Wave 4: Performance Tests
  console.log('\nWave 4: Running Performance Tests...');
  const perfResult = await runTestWave('@performance', 'Performance');
  results.push(perfResult);

  // Wave 5: Integration Tests (Vitest)
  console.log('\nWave 5: Running Integration Tests...');
  const integrationResult = await runVitestSuite('Integration');
  results.push(integrationResult);

  // Calculate summary
  const summary = {
    totalPassed: results.reduce((sum, r) => sum + r.passed, 0),
    totalFailed: results.reduce((sum, r) => sum + r.failed, 0),
    totalSkipped: results.reduce((sum, r) => sum + r.skipped, 0),
    totalDuration: results.reduce((sum, r) => sum + r.duration, 0),
  };

  return { timestamp, results, summary };
}

async function runTestWave(tag: string, name: string): Promise<TestResult> {
  const startTime = Date.now();
  let passed = 0;
  let failed = 0;
  let skipped = 0;
  const errors: string[] = [];

  try {
    const output = execSync(
      `npx playwright test --grep "${tag}" --reporter=json`,
      { encoding: 'utf-8', timeout: 300000, stdio: ['pipe', 'pipe', 'pipe'] }
    );

    const jsonResult = JSON.parse(output);
    passed = jsonResult.stats?.passed || 0;
    failed = jsonResult.stats?.failed || 0;
    skipped = jsonResult.stats?.skipped || 0;

  } catch (error: any) {
    // Parse error output
    if (error.stdout) {
      try {
        const jsonResult = JSON.parse(error.stdout);
        passed = jsonResult.stats?.passed || 0;
        failed = jsonResult.stats?.failed || 0;
        skipped = jsonResult.stats?.skipped || 0;

        if (jsonResult.suites) {
          for (const suite of jsonResult.suites) {
            for (const spec of suite.specs || []) {
              if (spec.ok === false) {
                errors.push(`${suite.title}: ${spec.title}`);
              }
            }
          }
        }
      } catch {
        errors.push(error.message || 'Unknown error');
        failed = 1;
      }
    } else {
      errors.push(error.message || 'Test execution failed');
      failed = 1;
    }
  }

  const duration = Date.now() - startTime;

  console.log(`  ${name}: ${passed} passed, ${failed} failed, ${skipped} skipped (${(duration/1000).toFixed(1)}s)`);

  return { wave: tag, name, passed, failed, skipped, duration, errors };
}

async function runVitestSuite(name: string): Promise<TestResult> {
  const startTime = Date.now();
  let passed = 0;
  let failed = 0;
  let skipped = 0;
  const errors: string[] = [];

  try {
    execSync('npm test -- --run', { encoding: 'utf-8', timeout: 120000, stdio: 'pipe' });
    passed = 1; // Vitest run passed

  } catch (error: any) {
    if (error.status === 0) {
      passed = 1;
    } else {
      failed = 1;
      errors.push(error.message || 'Vitest failed');
    }
  }

  const duration = Date.now() - startTime;
  console.log(`  ${name}: ${passed ? 'PASSED' : 'FAILED'} (${(duration/1000).toFixed(1)}s)`);

  return { wave: 'integration', name, passed, failed, skipped, duration, errors };
}

function generateReport(data: ReportData): string {
  const { timestamp, results, summary } = data;

  let report = `
# System-Wide Test Report

**Generated:** ${timestamp}
**Duration:** ${(summary.totalDuration / 1000).toFixed(1)} seconds

## Summary

| Metric | Count |
|--------|-------|
| Passed | ${summary.totalPassed} |
| Failed | ${summary.totalFailed} |
| Skipped | ${summary.totalSkipped} |
| Total | ${summary.totalPassed + summary.totalFailed + summary.totalSkipped} |

**Status:** ${summary.totalFailed === 0 ? 'ALL TESTS PASSED' : 'TESTS FAILED'}

## Results by Wave

`;

  for (const result of results) {
    const status = result.failed === 0 ? 'PASS' : 'FAIL';
    report += `### ${result.name} [${status}]\n\n`;
    report += `- Passed: ${result.passed}\n`;
    report += `- Failed: ${result.failed}\n`;
    report += `- Skipped: ${result.skipped}\n`;
    report += `- Duration: ${(result.duration / 1000).toFixed(1)}s\n`;

    if (result.errors.length > 0) {
      report += `\n**Errors:**\n`;
      for (const error of result.errors) {
        report += `- ${error}\n`;
      }
    }

    report += '\n';
  }

  report += `---
*Report generated by test-report-generator.ts*
`;

  return report;
}

// Main execution
runTests().then(data => {
  const report = generateReport(data);

  // Write report to file
  const reportPath = '.planning/phases/11-system-wide-testing/11-TEST-REPORT.md';
  fs.writeFileSync(reportPath, report);

  console.log('\n================================');
  console.log('TEST SUITE COMPLETE');
  console.log('================================');
  console.log(`\nPassed: ${data.summary.totalPassed}`);
  console.log(`Failed: ${data.summary.totalFailed}`);
  console.log(`Skipped: ${data.summary.totalSkipped}`);
  console.log(`Duration: ${(data.summary.totalDuration / 1000).toFixed(1)}s`);
  console.log(`\nReport saved to: ${reportPath}`);

  // Exit with error code if tests failed
  if (data.summary.totalFailed > 0) {
    process.exit(1);
  }
});
```

This script runs all tests in wave order and generates a markdown report.
  </action>
  <verify>
    - File exists at tests/test-report-generator.ts
    - TypeScript compiles: npm run build
  </verify>
  <done>Test report generator script created</done>
</task>

<task type="auto">
  <name>Task 2: Add npm script for full test suite</name>
  <files>package.json</files>
  <action>
Add npm script to package.json scripts section:

```json
"test:full": "tsx tests/test-report-generator.ts",
"test:report": "playwright show-report"
```

This allows running the complete test suite with: npm run test:full
  </action>
  <verify>
    - npm run test:full --help shows command exists
  </verify>
  <done>npm script added for full test suite execution</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 11 system-wide testing suite including:
- Test infrastructure (fixtures, config, npm scripts)
- Smoke tests (health, auth, navigation)
- Critical path E2E tests (dashboard, cases, tabs)
- New case flow E2E tests
- Performance tests (API response times, page load times)
- Database integrity tests
- Error handling edge case tests
- Test report generator
  </what-built>
  <how-to-verify>
1. Ensure server is running: npm run dev

2. Run smoke tests first (fast feedback):
   npm run test:e2e:smoke
   - Should see health check, auth, navigation tests pass

3. Run critical path tests:
   npm run test:e2e:critical
   - Should see dashboard, case list, case tabs tests

4. Run full test suite:
   npm run test:full
   - Generates report at .planning/phases/11-system-wide-testing/11-TEST-REPORT.md

5. View HTML report:
   npm run test:e2e:report

6. Review the test report:
   - Check pass/fail counts
   - Note any failing tests
   - Review performance baselines

7. Verify Phase 11 success criteria:
   [ ] Employer portal login and navigation verified
   [ ] All 7 case detail tabs functional with real data
   [ ] New case creation flow works end-to-end
   [ ] API performance meets targets (<5s response times)
   [ ] Playwright E2E tests pass for critical paths
   [ ] Database integrity verified
   [ ] Error handling graceful (no infinite loops)
   [ ] Recovery chart displays certificate dots correctly
  </how-to-verify>
  <resume-signal>Type "approved" if tests pass and meet success criteria, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After human approval:
1. All smoke tests pass
2. All critical path tests pass
3. Performance baselines established
4. Test report generated at .planning/phases/11-system-wide-testing/11-TEST-REPORT.md
5. Phase 11 success criteria met
</verification>

<success_criteria>
- test-report-generator.ts exists and compiles
- npm run test:full executes all test waves
- Test report generated with pass/fail summary
- Human verified: critical tests pass, system functional
- All Phase 11 success criteria from roadmap verified
</success_criteria>

<output>
After completion, create `.planning/phases/11-system-wide-testing/11-07-SUMMARY.md`
</output>
