---
phase: 07-email-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/schema.ts
  - server/storage.ts
  - server/services/rtwEmailService.ts
  - package.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Organization can have a custom RTW email template"
    - "Template uses variable substitution ({{workerName}}, etc.)"
    - "System falls back to AI generation when no template exists"
    - "Templates stored per organization"
  artifacts:
    - path: "shared/schema.ts"
      provides: "email_templates table definition"
      contains: "emailTemplates = pgTable"
    - path: "server/storage.ts"
      provides: "Template CRUD methods"
      exports: ["getEmailTemplate", "saveEmailTemplate"]
    - path: "server/services/rtwEmailService.ts"
      provides: "Template rendering with Handlebars fallback chain"
      contains: "renderFromTemplate"
  key_links:
    - from: "server/services/rtwEmailService.ts"
      to: "server/storage.ts"
      via: "getEmailTemplate call"
      pattern: "storage\\.getEmailTemplate"
    - from: "server/services/rtwEmailService.ts"
      to: "handlebars"
      via: "template rendering"
      pattern: "Handlebars\\.compile"
---

<objective>
Add organization-specific email template support for RTW plan manager notifications

Purpose: Enable organizations to customize their RTW plan email content, tone, and branding (EMAIL-09)
Output: Database table for templates, storage methods, and template resolution in rtwEmailService
</objective>

<execution_context>
@C:\Users\Paul\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Paul\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-email-generation/07-RESEARCH.md

# Prior work - email service already exists from Phase 6
@server/services/rtwEmailService.ts
@server/storage.ts
@shared/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add email_templates table and storage methods</name>
  <files>
    shared/schema.ts
    server/storage.ts
  </files>
  <action>
1. In shared/schema.ts, add email_templates table after emailDrafts:

```typescript
// Email Templates - Organization-specific email templates (EMAIL-09)
export const emailTemplates = pgTable("email_templates", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  organizationId: varchar("organization_id").notNull().references(() => organizations.id),
  templateType: varchar("template_type").notNull(), // 'rtw_plan_notification', 'certificate_chase', etc.
  templateName: varchar("template_name"), // User-friendly name
  subjectTemplate: text("subject_template").notNull(),
  bodyTemplate: text("body_template").notNull(),
  format: varchar("format").notNull().default("plain"), // 'plain' or 'html'
  isActive: boolean("is_active").notNull().default(true),
  createdBy: varchar("created_by").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export type EmailTemplateDB = typeof emailTemplates.$inferSelect;
export type InsertEmailTemplate = typeof emailTemplates.$inferInsert;
```

2. In server/storage.ts, add storage methods:
   - getEmailTemplate(organizationId: string, templateType: string): Promise<EmailTemplateDB | null>
   - saveEmailTemplate(template: InsertEmailTemplate): Promise<EmailTemplateDB>
   - updateEmailTemplate(id: string, updates: Partial<InsertEmailTemplate>): Promise<EmailTemplateDB | null>

Use existing pattern from similar storage methods. Query should filter by organizationId, templateType, and isActive=true.
  </action>
  <verify>
    npm run build passes without type errors
    grep -n "emailTemplates" shared/schema.ts shows table definition
    grep -n "getEmailTemplate" server/storage.ts shows storage method
  </verify>
  <done>
    email_templates table defined in schema
    Storage methods for template CRUD exist
    TypeScript compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate template rendering into rtwEmailService</name>
  <files>
    server/services/rtwEmailService.ts
    package.json
  </files>
  <action>
1. Install Handlebars (lightweight template engine):
   npm install handlebars
   npm install --save-dev @types/handlebars

2. Update rtwEmailService.ts to add template resolution:

```typescript
import Handlebars from "handlebars";
import { storage } from "../storage";

// Add after existing imports and before generateRTWPlanEmail

/**
 * Template variable context for Handlebars rendering
 */
interface TemplateVariables {
  workerName: string;
  company: string;
  dateOfInjury: string;
  workStatus: string;
  roleName: string;
  roleDescription?: string | null;
  planType: string;
  planTypeLabel: string;
  planStatus: string;
  startDate: string;
  restrictionReviewDate?: string | null;
  scheduleSummary: string;
  includedDutiesList: string;
  excludedDutiesList: string;
}

/**
 * Build template variables from plan context
 */
function buildTemplateVariables(context: RTWPlanEmailContext): TemplateVariables {
  const planTypeLabel = PLAN_TYPE_LABELS[context.planType] || context.planType;
  const scheduleSummary = formatScheduleSummary(context.schedule);

  const includedDutiesList = context.includedDuties
    .map((d) => `- ${d.dutyName}${d.modificationNotes ? ` (modifications: ${d.modificationNotes})` : ""}`)
    .join("\n");

  const excludedDutiesList = context.excludedDuties
    .map((d) => `- ${d.dutyName}${d.excludedReason ? ` (${d.excludedReason})` : ""}`)
    .join("\n");

  return {
    workerName: context.workerName,
    company: context.company,
    dateOfInjury: context.dateOfInjury,
    workStatus: context.workStatus,
    roleName: context.roleName,
    roleDescription: context.roleDescription,
    planType: context.planType,
    planTypeLabel,
    planStatus: context.planStatus,
    startDate: context.startDate,
    restrictionReviewDate: context.restrictionReviewDate,
    scheduleSummary,
    includedDutiesList: includedDutiesList || "No included duties",
    excludedDutiesList: excludedDutiesList || "No excluded duties",
  };
}

/**
 * Render email from organization template
 */
async function renderFromTemplate(
  organizationId: string,
  context: RTWPlanEmailContext
): Promise<GeneratedEmail | null> {
  const template = await storage.getEmailTemplate(organizationId, "rtw_plan_notification");

  if (!template || !template.isActive) {
    return null;
  }

  try {
    const variables = buildTemplateVariables(context);

    const subjectCompiled = Handlebars.compile(template.subjectTemplate);
    const bodyCompiled = Handlebars.compile(template.bodyTemplate);

    return {
      subject: subjectCompiled(variables),
      body: bodyCompiled(variables),
    };
  } catch (error) {
    logger.api.error("Template rendering failed", { organizationId }, error);
    return null;
  }
}
```

3. Modify generateRTWPlanEmail signature to accept optional organizationId:

```typescript
export async function generateRTWPlanEmail(
  context: RTWPlanEmailContext,
  organizationId?: string
): Promise<GeneratedEmail> {
  // 1. Try organization-specific template first (EMAIL-09)
  if (organizationId) {
    const templateResult = await renderFromTemplate(organizationId, context);
    if (templateResult) {
      logger.api.info("Generated RTW email from template", {
        workerName: context.workerName,
        organizationId,
      });
      return templateResult;
    }
  }

  // 2. Fall back to AI generation (existing behavior)
  // ... rest of existing code unchanged ...
}
```

4. Keep all existing code after the template check - the AI generation and fallback template.
  </action>
  <verify>
    npm run build passes without type errors
    grep -n "Handlebars" server/services/rtwEmailService.ts shows import
    grep -n "renderFromTemplate" server/services/rtwEmailService.ts shows function
    grep -n "organizationId" server/services/rtwEmailService.ts shows parameter usage
  </verify>
  <done>
    Handlebars installed as dependency
    Template rendering function exists
    generateRTWPlanEmail accepts organizationId parameter
    Template -> AI -> Fallback chain implemented
  </done>
</task>

<task type="auto">
  <name>Task 3: Update API endpoint to pass organizationId and apply migration</name>
  <files>
    server/routes/rtwPlans.ts
  </files>
  <action>
1. Find the GET /api/rtw-plans/:planId/email endpoint in server/routes/rtwPlans.ts

2. Update the generateRTWPlanEmail call to pass organizationId from the plan context:

```typescript
// After getting plan details, get organizationId from the case
const workerCase = await storage.getCaseById(plan.caseId);
const organizationId = workerCase?.organizationId;

const emailResult = await generateRTWPlanEmail(emailContext, organizationId);
```

3. Similarly update the POST /api/rtw-plans/:planId/email/regenerate endpoint to pass organizationId.

4. Run npm run db:push to create the email_templates table in the database.
  </action>
  <verify>
    npm run build passes
    npm run db:push runs successfully (creates email_templates table)
    curl to /api/rtw-plans/{planId}/email still works (falls back to AI)
  </verify>
  <done>
    API endpoints pass organizationId to email service
    Database migration applied (email_templates table created)
    Existing email generation still works via fallback chain
  </done>
</task>

</tasks>

<verification>
1. TypeScript builds without errors: `npm run build`
2. Database migration successful: `npm run db:push`
3. Existing email generation still works (AI fallback)
4. Template table exists: Check database for email_templates table
</verification>

<success_criteria>
- email_templates table created in database
- Storage methods for template CRUD available
- rtwEmailService uses template -> AI -> fallback chain
- API endpoints pass organizationId to email service
- Existing functionality preserved (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/07-email-generation/07-01-SUMMARY.md`
</output>
