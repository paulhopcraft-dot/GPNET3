---
phase: 03-medical-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - server/services/restrictionMapper.ts
  - server/storage.ts
  - server/routes/restrictions.ts
  - server/routes.ts
autonomous: true

must_haves:
  truths:
    - "Multiple certificates combine using most restrictive logic"
    - "Current restrictions are queryable by case ID"
    - "API endpoint returns structured restriction data"
  artifacts:
    - path: "server/services/restrictionMapper.ts"
      provides: "Multi-certificate aggregation with priority logic"
      exports: ["combineRestrictions", "getMostRestrictive"]
    - path: "server/storage.ts"
      provides: "getCurrentRestrictions method"
      contains: "getCurrentRestrictions"
    - path: "server/routes/restrictions.ts"
      provides: "GET /api/cases/:id/current-restrictions endpoint"
      exports: ["default"]
  key_links:
    - from: "server/routes/restrictions.ts"
      to: "server/storage.ts"
      via: "storage.getCurrentRestrictions"
      pattern: "storage\\.getCurrentRestrictions"
    - from: "server/storage.ts"
      to: "server/services/restrictionMapper.ts"
      via: "combineRestrictions import"
      pattern: "combineRestrictions"
---

<objective>
Create the restriction mapper service for multi-certificate aggregation and the API endpoint to retrieve current restrictions for a case.

Purpose: MED-10 requires combining multiple active restrictions with "most restrictive wins" logic. The API endpoint enables the RTW planning screen to display current restrictions (MED-09).

Output: restrictionMapper.ts service, getCurrentRestrictions in storage.ts, GET /api/cases/:id/current-restrictions endpoint

**Note:** This plan has 3 tasks with aggregation complexity. Allow extra debugging time if combineRestrictions edge cases arise.
</objective>

<execution_context>
@D:\dev\gpnet3\.claude/get-shit-done/workflows/execute-plan.md
@D:\dev\gpnet3\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-medical-integration/03-RESEARCH.md
@.planning/phases/03-medical-integration/03-01-SUMMARY.md
@shared/schema.ts (FunctionalRestrictions, RestrictionCapability types)
@server/storage.ts (existing query patterns)
@server/routes.ts (route registration pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create restrictionMapper.ts with combination logic</name>
  <files>server/services/restrictionMapper.ts</files>
  <action>
Create `server/services/restrictionMapper.ts` that implements "most restrictive wins" logic for MED-10:

1. Define CAPABILITY_PRIORITY constant:
```typescript
const CAPABILITY_PRIORITY: Record<RestrictionCapability, number> = {
  cannot: 3,
  with_modifications: 2,
  can: 1,
  not_assessed: 0,
};
```

2. Implement `getMostRestrictive` function:
- Takes array of RestrictionCapability values
- Returns the highest priority (most restrictive) capability
- Handle empty arrays gracefully (return "not_assessed")

3. Implement `combineRestrictions` function:
- Takes array of FunctionalRestrictions objects
- Returns single FunctionalRestrictions using most restrictive logic for each field
- For numeric fields (liftingMaxKg, carryingMaxKg):
  - Use minimum value (lower weight = more restrictive)
  - Filter out null/undefined before calculating
- For time fields (exerciseMinutesPerHour, restMinutesPerHour):
  - Use maximum value (more rest = more restrictive)
- For nextExaminationDate:
  - Use earliest date (soonest review = most restrictive)

4. Export both functions

Example logic for combining:
```typescript
return {
  sitting: getMostRestrictive(restrictionsList.map(r => r.sitting)),
  standingWalking: getMostRestrictive(restrictionsList.map(r => r.standingWalking)),
  // ... all fields
  liftingMaxKg: getMinimumNonNull(restrictionsList.map(r => r.liftingMaxKg)),
  // ...
};
```
  </action>
  <verify>
Run `npm run build` - TypeScript compiles without errors.
  </verify>
  <done>
restrictionMapper.ts exports combineRestrictions and getMostRestrictive functions implementing MED-10 logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add getCurrentRestrictions to storage.ts</name>
  <files>server/storage.ts</files>
  <action>
Add a new method to the Storage class in `server/storage.ts`:

1. **Import combineRestrictions at the top of the file:**
```typescript
import { combineRestrictions } from "./services/restrictionMapper";
import type { FunctionalRestrictions } from "@shared/schema";
```

2. Add method signature to IStorage interface (typically near the top of the file with other method signatures)

3. Implement `getCurrentRestrictions` method:
```typescript
async getCurrentRestrictions(
  caseId: string,
  organizationId: string
): Promise<{
  restrictions: FunctionalRestrictions;
  maxWorkHoursPerDay: number | null;
  maxWorkDaysPerWeek: number | null;
  source: "single_certificate" | "combined";
  certificateCount: number;
} | null>
```

4. Query logic:
- Find certificates where caseId matches AND (isCurrentCertificate = true OR endDate >= today)
- Order by endDate DESC
- Return null if no certificates found

5. **Aggregation logic with explicit combineRestrictions call:**
```typescript
// Extract functionalRestrictionsJson from each certificate
const restrictionsList = certificates
  .map(cert => cert.functionalRestrictionsJson)
  .filter((r): r is FunctionalRestrictions => r !== null && r !== undefined);

if (restrictionsList.length === 0) {
  // No certificates have extracted restrictions yet
  logger.storage.warn("No functional restrictions found for certificates", { caseId, certificateCount: certificates.length });
  return null;
}

if (restrictionsList.length === 1) {
  // Single certificate - return directly
  return {
    restrictions: restrictionsList[0],
    maxWorkHoursPerDay: certificates[0].maxWorkHoursPerDay ?? null,
    maxWorkDaysPerWeek: certificates[0].maxWorkDaysPerWeek ?? null,
    source: "single_certificate",
    certificateCount: 1,
  };
}

// Multiple certificates - combine using most restrictive logic
const combined = combineRestrictions(restrictionsList);
return {
  restrictions: combined,
  maxWorkHoursPerDay: Math.min(...certificates.map(c => c.maxWorkHoursPerDay).filter((h): h is number => h !== null)),
  maxWorkDaysPerWeek: Math.min(...certificates.map(c => c.maxWorkDaysPerWeek).filter((d): d is number => d !== null)),
  source: "combined",
  certificateCount: restrictionsList.length,
};
```

6. Handle edge case where certificates exist but none have functionalRestrictionsJson:
- Return null with appropriate logging
- This signals that extraction hasn't run yet

Add the method to the IStorage interface as well.
  </action>
  <verify>
Run `npm run build` - TypeScript compiles without errors.
Run `npm test` - existing tests pass.
  </verify>
  <done>
storage.getCurrentRestrictions method exists with explicit combineRestrictions call for multi-certificate scenarios.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create restrictions API route</name>
  <files>server/routes/restrictions.ts, server/routes.ts</files>
  <action>
Create `server/routes/restrictions.ts`:

1. Create Express router with:
```typescript
import { Router } from "express";
import { authorize, type AuthRequest } from "../middleware/auth";
import { requireCaseOwnership } from "../middleware/caseOwnership";
import { storage } from "../storage";
import { logger } from "../lib/logger";

const router = Router();
```

2. Implement GET endpoint:
```typescript
/**
 * GET /api/cases/:id/current-restrictions
 * Returns current medical restrictions for RTW planning screen
 *
 * Requirements: MED-09
 */
router.get("/:id/current-restrictions",
  authorize(),
  requireCaseOwnership(),
  async (req: AuthRequest, res) => {
    try {
      const result = await storage.getCurrentRestrictions(
        req.params.id,
        req.user!.organizationId
      );

      if (!result) {
        return res.status(404).json({
          error: "No current medical certificate with restrictions found",
          hint: "Ensure a valid medical certificate exists with extracted restrictions"
        });
      }

      res.json({
        restrictions: result.restrictions,
        maxWorkHoursPerDay: result.maxWorkHoursPerDay,
        maxWorkDaysPerWeek: result.maxWorkDaysPerWeek,
        source: result.source,
        certificateCount: result.certificateCount,
        retrievedAt: new Date().toISOString(),
      });
    } catch (err) {
      logger.api.error("Failed to fetch current restrictions", { caseId: req.params.id }, err);
      res.status(500).json({
        error: "Failed to fetch restrictions",
        details: err instanceof Error ? err.message : "Unknown error"
      });
    }
  }
);

export default router;
```

3. Register in `server/routes.ts`:
- Import: `import restrictionRoutes from "./routes/restrictions";`
- Add after case-related routes: `app.use("/api/cases", restrictionRoutes);`
  </action>
  <verify>
Run `npm run build` - TypeScript compiles without errors.
Start server and test: `curl http://localhost:5000/api/cases/{caseId}/current-restrictions` (with auth token).
  </verify>
  <done>
GET /api/cases/:id/current-restrictions endpoint is registered and functional.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. `npm test` passes
3. server/services/restrictionMapper.ts exports combineRestrictions
4. storage.getCurrentRestrictions method exists and imports combineRestrictions
5. GET /api/cases/:id/current-restrictions returns 200 for valid case with restrictions
6. API returns 404 when no restrictions found (not 500)
</verification>

<success_criteria>
- Multiple certificates combine correctly (most restrictive wins)
- Priority order: cannot > with_modifications > can > not_assessed
- Weight limits use minimum (more restrictive)
- Rest requirements use maximum (more restrictive)
- API endpoint is JWT-protected with case ownership check
- Response includes source indicator (single vs combined)
</success_criteria>

<output>
After completion, create `.planning/phases/03-medical-integration/03-02-SUMMARY.md`
</output>
