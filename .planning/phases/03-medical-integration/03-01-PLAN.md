---
phase: 03-medical-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/schema.ts
  - server/services/restrictionExtractor.ts
  - server/services/certificateService.ts
autonomous: true

must_haves:
  truths:
    - "Certificate restrictions can be parsed into FunctionalRestrictions format"
    - "Claude Haiku extracts structured capability data from certificate text"
    - "Extraction confidence is tracked for quality assurance"
    - "Extraction runs automatically when certificates are uploaded"
  artifacts:
    - path: "shared/schema.ts"
      provides: "FunctionalRestrictionsJson field on medical_certificates"
      contains: "functionalRestrictionsJson"
    - path: "server/services/restrictionExtractor.ts"
      provides: "LLM-based restriction extraction service"
      exports: ["extractFunctionalRestrictions", "RestrictionExtractionResult"]
    - path: "server/services/certificateService.ts"
      provides: "Integration point calling extraction after certificate creation"
      contains: "extractFunctionalRestrictions"
  key_links:
    - from: "server/services/restrictionExtractor.ts"
      to: "anthropic Claude API"
      via: "Anthropic SDK client"
      pattern: "client\\.messages\\.create"
    - from: "server/services/certificateService.ts"
      to: "server/services/restrictionExtractor.ts"
      via: "import and call extractFunctionalRestrictions"
      pattern: "extractFunctionalRestrictions"
---

<objective>
Create the restriction extraction service that parses medical certificate data into structured FunctionalRestrictions format using Claude Haiku.

Purpose: MED-01, MED-02, MED-03 through MED-08 depend on having structured extraction of restrictions from certificate data. This service transforms semi-structured certificate notes and restriction arrays into the FunctionalRestrictions interface that matches the RTW duty demands structure.

Output: restrictionExtractor.ts service with LLM-based extraction, schema updated with functionalRestrictionsJson field, integration into certificate upload flow
</objective>

<execution_context>
@D:\dev\gpnet3\.claude/get-shit-done/workflows/execute-plan.md
@D:\dev\gpnet3\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-medical-integration/03-RESEARCH.md
@shared/schema.ts (FunctionalRestrictions interface at line 1625-1651)
@server/services/certificateService.ts (existing Claude Haiku patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add functionalRestrictionsJson field to medical_certificates schema</name>
  <files>shared/schema.ts</files>
  <action>
Add a new JSONB field `functionalRestrictionsJson` to the `medicalCertificates` table definition (around line 778, after rawExtractedData).

The field should store structured FunctionalRestrictions data:
```typescript
functionalRestrictionsJson: jsonb("functional_restrictions_json").$type<FunctionalRestrictions | null>(),
```

Also add time limit fields that research identified as important (around the FunctionalRestrictions interface or as part of the extraction result):
- maxWorkHoursPerDay?: number
- maxWorkDaysPerWeek?: number

These can be added to the interface or stored alongside in the JSONB.

Do NOT modify the RestrictionItem type or existing restrictions field - we augment, not replace.
  </action>
  <verify>
Run `npm run build` - TypeScript compiles without errors.
Check that FunctionalRestrictions interface exists and medical_certificates table has the new field.
  </verify>
  <done>
medical_certificates table has functionalRestrictionsJson field that can store FunctionalRestrictions data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create restrictionExtractor.ts service</name>
  <files>server/services/restrictionExtractor.ts</files>
  <action>
Create a new service file at `server/services/restrictionExtractor.ts` that:

1. Imports Anthropic SDK and types from @shared/schema (FunctionalRestrictions, RestrictionItem, RestrictionCapability)

2. Defines RestrictionExtractionResult interface:
```typescript
interface RestrictionExtractionResult {
  restrictions: FunctionalRestrictions;
  maxWorkHoursPerDay: number | null;
  maxWorkDaysPerWeek: number | null;
  confidence: number;
}
```

3. Implements `extractFunctionalRestrictions` function that:
   - Takes input: { capacity: string, notes?: string, restrictions?: RestrictionItem[], workCapacityPercentage?: number }
   - Uses Claude Haiku (claude-3-haiku-20240307) - same model as certificateService.ts
   - Builds a structured extraction prompt that asks Claude to classify each demand category as: "can" | "with_modifications" | "cannot" | "not_assessed"
   - Extracts numeric limits: liftingMaxKg, carryingMaxKg, maxWorkHoursPerDay, maxWorkDaysPerWeek
   - Parses Claude's JSON response with error handling
   - Returns RestrictionExtractionResult with confidence score

4. Uses logger from "../lib/logger" for logging (pattern from certificateService.ts)

5. Handles edge cases:
   - Empty/null notes: return all fields as "not_assessed" with low confidence
   - "fit" capacity with no restrictions: return all fields as "can"
   - "unfit" capacity: return all physical demands as "cannot"
   - Low confidence parse: return requiresReview flag

Use the prompt structure from research:
- List all physical demands (sitting, standingWalking, bending, squatting, kneelingClimbing, twisting, reachingOverhead, reachingForward, neckMovement, lifting, carrying, pushing, pulling, repetitiveMovements, useOfInjuredLimb)
- Request JSON-only response matching FunctionalRestrictions schema

**For MED-06 repetitiveMovements:** Extract frequency limits when present (e.g., "max 50 repetitions per hour"). If the certificate specifies quantitative limits, include them in a separate field `repetitiveMovementsMaxPerHour?: number`. If only capability is stated without frequency, extract the capability as usual (this is the most common case in certificates).
  </action>
  <verify>
Run `npm run build` - TypeScript compiles without errors.
Run `npm test` - existing tests pass (new service has no tests yet).
  </verify>
  <done>
restrictionExtractor.ts exists with extractFunctionalRestrictions function that can process certificate data and return structured FunctionalRestrictions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run database migration for new field</name>
  <files>drizzle migrations</files>
  <action>
Generate and apply the database migration for the new functionalRestrictionsJson field:

1. Run `npm run drizzle:generate` to create migration file
2. Run `npm run db:push` to apply changes to the database

If db:push fails due to existing data, the JSONB field should accept null by default so existing rows are unaffected.
  </action>
  <verify>
`npm run db:push` completes successfully.
Query database to confirm medical_certificates table has functional_restrictions_json column.
  </verify>
  <done>
Database schema updated with functional_restrictions_json column on medical_certificates table.
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate extraction into certificate upload flow</name>
  <files>server/services/certificateService.ts</files>
  <action>
Add extraction trigger to the certificate upload/creation flow in `server/services/certificateService.ts`:

1. Import the extraction function at the top of the file:
```typescript
import { extractFunctionalRestrictions } from "./restrictionExtractor";
```

2. Locate the certificate creation/upload function (likely `createCertificate` or similar that handles new certificate uploads)

3. After the certificate is created/saved with raw data, add extraction call:
```typescript
// After certificate is created and raw data is available
try {
  const extractionResult = await extractFunctionalRestrictions({
    capacity: certificate.capacity || "",
    notes: certificate.notes || certificate.rawExtractedData?.summary,
    restrictions: certificate.restrictions,
    workCapacityPercentage: certificate.workCapacityPercentage,
  });

  // Update certificate with extracted restrictions
  await db.update(medicalCertificates)
    .set({
      functionalRestrictionsJson: extractionResult.restrictions,
      // Store time limits if schema supports, or include in JSONB
    })
    .where(eq(medicalCertificates.id, certificate.id));

  logger.extraction.info("Extracted functional restrictions", {
    certificateId: certificate.id,
    confidence: extractionResult.confidence,
  });
} catch (extractionErr) {
  // Log but don't fail the upload - extraction can be retried
  logger.extraction.error("Restriction extraction failed", {
    certificateId: certificate.id,
  }, extractionErr);
}
```

4. Ensure extraction runs asynchronously (fire-and-forget) if it's slow, OR runs synchronously if response time is acceptable (certificate uploads already use LLM)

5. Handle case where certificate already has functionalRestrictionsJson (skip re-extraction unless forced)

This ensures MED-01 through MED-08 data is populated as certificates are uploaded, not requiring a separate batch process.
  </action>
  <verify>
Run `npm run build` - TypeScript compiles without errors.
Run `npm test` - existing tests pass.
Manual verification: Upload a certificate and confirm functionalRestrictionsJson is populated.
  </verify>
  <done>
Certificate upload flow triggers extraction automatically, populating functionalRestrictionsJson for new certificates.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. `npm test` passes
3. shared/schema.ts has functionalRestrictionsJson field on medicalCertificates
4. server/services/restrictionExtractor.ts exports extractFunctionalRestrictions
5. Database has functional_restrictions_json column
6. Certificate upload flow calls extractFunctionalRestrictions
</verification>

<success_criteria>
- FunctionalRestrictions can be stored on medical certificates
- Extraction service can parse certificate data using Claude Haiku
- All demand categories covered: sitting, standing/walking, bending, squatting, kneeling/climbing, twisting, reaching overhead, reaching forward, neck movement, lifting, carrying, pushing, pulling, repetitive movements, use of injured limb
- Time limits extracted: maxWorkHoursPerDay, maxWorkDaysPerWeek
- Weight limits extracted: liftingMaxKg, carryingMaxKg
- Extraction runs automatically on certificate upload
</success_criteria>

<output>
After completion, create `.planning/phases/03-medical-integration/03-01-SUMMARY.md`
</output>
