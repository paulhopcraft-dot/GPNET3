---
phase: 04-functional-ability-matrix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/services/functionalAbilityCalculator.ts
  - server/services/modificationSuggester.ts
  - server/services/functionalAbilityCalculator.test.ts
autonomous: true

must_haves:
  truths:
    - "Suitability calculation produces ONLY three possible outputs: suitable, suitable_with_modification, not_suitable"
    - "calculateDutySuitability NEVER returns undefined, null, or invalid states"
    - "Capability 'cannot' always results in not_suitable when frequency > never"
    - "Capability 'can' always results in suitable"
    - "Weight limits compared correctly (worker limit >= duty requirement = suitable)"
    - "Missing restrictions handled as not_assessed, not as can"
    - "Modification suggestions generated for problematic demands"
  artifacts:
    - path: "server/services/functionalAbilityCalculator.ts"
      provides: "Core suitability calculation algorithm"
      exports: ["calculateDutySuitability", "compareDemandToCapability", "SuitabilityLevel", "SuitabilityResult"]
    - path: "server/services/modificationSuggester.ts"
      provides: "Modification suggestion generation"
      exports: ["generateModificationSuggestions"]
    - path: "server/services/functionalAbilityCalculator.test.ts"
      provides: "Unit tests for calculator"
      min_lines: 120
  key_links:
    - from: "server/services/functionalAbilityCalculator.ts"
      to: "@shared/schema"
      via: "type imports"
      pattern: "import.*FunctionalRestrictions.*RTWDutyDemandsDB"
    - from: "server/services/modificationSuggester.ts"
      to: "server/services/functionalAbilityCalculator.ts"
      via: "DemandComparison type import"
      pattern: "import.*DemandComparison"
---

<objective>
Create the core suitability calculation algorithm that compares worker restrictions against duty demands.

Purpose: This is the algorithmic heart of the Functional Ability Matrix - the logic that determines whether a worker can safely perform each duty based on their medical restrictions.

Output: Two services (functionalAbilityCalculator.ts, modificationSuggester.ts) with unit tests
</objective>

<execution_context>
@C:\Users\Paul\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Paul\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-functional-ability-matrix/04-RESEARCH.md

# Key existing files
@shared/schema.ts (lines 1600-1668 for FunctionalRestrictions, RTWDutyDemandsDB types)
@server/services/restrictionMapper.ts (CAPABILITY_PRIORITY constant, combination patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Functional Ability Calculator Service</name>
  <files>server/services/functionalAbilityCalculator.ts</files>
  <action>
Create the core suitability calculation algorithm based on the research patterns in 04-RESEARCH.md.

**Types to export:**
```typescript
export type SuitabilityLevel = "suitable" | "suitable_with_modification" | "not_suitable";

export interface DemandComparison {
  demand: string;
  frequency: DemandFrequency;
  capability: RestrictionCapability;
  match: SuitabilityLevel;
  reason: string;
}

export interface SuitabilityResult {
  overallSuitability: SuitabilityLevel;
  demandComparisons: DemandComparison[];
  modificationSuggestions: string[];
  reasons: string[];
  confidence: number; // 0-1 based on data completeness
  warnings: string[]; // Missing data warnings
}
```

**Core functions:**
1. `compareDemandToCapability(demandName, frequency, capability)` - Single demand comparison
   - frequency "never" = always suitable (demand not required)
   - capability "cannot" + frequency > "never" = not_suitable
   - capability "can" = suitable
   - capability "with_modifications" + frequency "occasionally" = suitable_with_modification
   - capability "with_modifications" + frequency "frequently"/"constantly" = not_suitable
   - capability "not_assessed" = suitable_with_modification (flag for review)

2. `compareWeightLimit(demandName, dutyMaxKg, restrictionMaxKg, frequency, capability)` - Weight comparison
   - No duty weight or frequency "never" = use capability only
   - restrictionMaxKg >= dutyMaxKg = suitable
   - Difference <= 5kg + frequency "occasionally" = suitable_with_modification
   - Otherwise = not_suitable

3. `calculateDutySuitability(dutyDemands, restrictions, isModifiable)` - Main entry point
   - Compare all physical demands (sitting, standing, walking, bending, squatting, kneeling, twisting, reaching overhead/forward, repetitive movements)
   - Compare weight demands (lifting, carrying with max kg)
   - Compare cognitive demands (concentration, stressTolerance, workPace - default to "not_assessed" if missing)
   - Count not_suitable and with_modification matches
   - Apply modifiability: if duty is modifiable and not_suitable count <= 3, downgrade to suitable_with_modification
   - **CRITICAL: This function MUST return a valid SuitabilityResult with overallSuitability being one of the three SuitabilityLevel values. It must NEVER return undefined or null.**

4. `handleMissingRestrictions(restrictions)` - Handle null/partial data
   - Return default restrictions with all "not_assessed"
   - Calculate confidence score based on completeness
   - Generate warnings for missing critical fields

5. `handleMissingDemands(demands)` - Handle null demand data
   - Return default demands with all "never"
   - Generate warning

**Important mapping note:**
The demand field "kneeling" maps to restriction field "kneelingClimbing".
The demand fields "standing"/"walking" both map to restriction field "standingWalking".

Use DemandFrequency and RestrictionCapability types from @shared/schema.
  </action>
  <verify>
- `npm run build` passes with no TypeScript errors
- File exports all required types and functions
- File imports types from @shared/schema correctly
  </verify>
  <done>
functionalAbilityCalculator.ts created with calculateDutySuitability as main entry point, all comparison logic implemented per research patterns, handles missing data gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Modification Suggester Service</name>
  <files>server/services/modificationSuggester.ts</files>
  <action>
Create modification suggestion generator based on research patterns in 04-RESEARCH.md.

**Function:**
```typescript
export function generateModificationSuggestions(context: {
  dutyName: string;
  dutyDescription: string;
  demandComparisons: DemandComparison[];
  isModifiable: boolean;
}): string[]
```

**Demand-specific suggestions:**
- Lifting/Carrying: "Use mechanical aids (trolleys, hoists, team lifts)", "Redistribute heavy lifting to team"
- Bending/Squatting: "Raise work surface height", "Use long-handled tools"
- Standing: "Provide sit-stand workstation or stool", "Allow position changes every 30 min"
- Sitting: "Provide standing desk option", "Ergonomic chair with lumbar support"
- Reaching Overhead: "Store items at waist height", "Provide step ladder or reaching aids"
- Repetitive Movements: "Rotate tasks every 1-2 hours", "Allow micro-breaks (5 min/hour)"
- Concentration/Stress: "Reduce distractions", "Provide written instructions", "Allow extra time"
- Work Pace: "Adjust productivity targets", "Flexible deadlines"

**General suggestions (always add if any problematic demands):**
- "Gradual increase in duty demands over 2-4 weeks"
- "Regular check-ins with supervisor to assess tolerance"

**Deduplicate suggestions** using Set before returning.

Import DemandComparison type from functionalAbilityCalculator.ts.
  </action>
  <verify>
- `npm run build` passes
- File exports generateModificationSuggestions function
- Import from functionalAbilityCalculator works
  </verify>
  <done>
modificationSuggester.ts created with context-aware suggestions for each demand type, deduplication logic, general suggestions added.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Unit Tests for Calculator (including FAM-02 verification)</name>
  <files>server/services/functionalAbilityCalculator.test.ts</files>
  <action>
Create comprehensive unit tests using Vitest.

**Test categories:**

1. **FAM-02: Suitability output type verification (CRITICAL):**
   - Test that calculateDutySuitability() ONLY returns one of: 'suitable' | 'suitable_with_modification' | 'not_suitable'
   - Test that return value is NEVER undefined, null, empty string, or any other value
   - Test with various edge case inputs (empty demands, null restrictions, missing fields)
   - Example test:
   ```typescript
   it('should only return valid SuitabilityLevel values', () => {
     const validValues = ['suitable', 'suitable_with_modification', 'not_suitable'];
     const result = calculateDutySuitability(mockDemands, mockRestrictions, true);
     expect(validValues).toContain(result.overallSuitability);
     expect(result.overallSuitability).not.toBeUndefined();
     expect(result.overallSuitability).not.toBeNull();
   });
   ```

2. **compareDemandToCapability tests:**
   - "cannot" + "frequently" = not_suitable
   - "cannot" + "never" = suitable (no demand)
   - "can" + any frequency = suitable
   - "with_modifications" + "occasionally" = suitable_with_modification
   - "with_modifications" + "constantly" = not_suitable
   - "not_assessed" + any = suitable_with_modification

3. **compareWeightLimit tests:**
   - Worker limit 20kg >= duty 15kg = suitable
   - Worker limit 10kg < duty 20kg, frequently = not_suitable
   - Worker limit 15kg < duty 20kg (diff 5kg), occasionally = suitable_with_modification
   - No duty weight = use capability only
   - No worker weight limit = use capability only

4. **calculateDutySuitability tests:**
   - All capabilities "can", all frequencies low = suitable overall
   - Single "cannot" on frequently required = not_suitable (if not modifiable)
   - Single "cannot" on frequently required + duty modifiable = suitable_with_modification
   - Multiple "cannot" (>3) even if modifiable = not_suitable
   - Cognitive demands not_assessed default = suitable_with_modification

5. **handleMissingRestrictions tests:**
   - null restrictions = all not_assessed, confidence 0, warning generated
   - Partial restrictions = confidence < 1, warning for missing critical fields
   - Complete restrictions = confidence 1, no warnings

6. **generateModificationSuggestions tests:**
   - Lifting demand generates mechanical aids suggestion
   - Multiple demands generate multiple suggestions
   - Suggestions are deduplicated
   - General suggestions always added when issues exist

Use `describe` and `it` blocks. Mock RTWDutyDemandsDB and FunctionalRestrictions objects for testing.
  </action>
  <verify>
- `npm test server/services/functionalAbilityCalculator.test.ts` passes
- At least 18 test cases covering core scenarios including FAM-02 verification
- FAM-02 specific tests verify suitability value constraints
  </verify>
  <done>
Unit tests pass, covering all comparison functions, edge cases for missing data, weight limits, modification suggestions, AND explicit FAM-02 verification that calculateDutySuitability only returns valid SuitabilityLevel values.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. `npm test server/services/functionalAbilityCalculator.test.ts` passes all tests
3. Both services export correct types and functions
4. CAPABILITY_PRIORITY from restrictionMapper.ts NOT duplicated (use existing)
5. FAM-02 specific tests verify suitability never returns undefined/null/invalid
</verification>

<success_criteria>
- calculateDutySuitability correctly produces three-tier suitability output
- calculateDutySuitability NEVER returns undefined, null, or invalid states (FAM-02)
- Weight limit comparison handles edge cases (no limit, within margin)
- Missing data returns not_assessed with warnings, not false positives
- Modification suggestions are contextual and deduplicated
- All unit tests pass including FAM-02 verification tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-functional-ability-matrix/04-01-SUMMARY.md`
</output>
